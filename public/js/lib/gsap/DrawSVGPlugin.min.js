(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // <stdin>
  var require_stdin = __commonJS({
    "<stdin>"(exports, module) {
      !function(e, t) {
        "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {});
      }(exports, function(e) {
        "use strict";
        function l() {
          return "undefined" != typeof window;
        }
        function m() {
          return t || l() && (t = window.gsap) && t.registerPlugin && t;
        }
        function p(e2) {
          return Math.round(1e4 * e2) / 1e4;
        }
        function q(e2) {
          return parseFloat(e2) || 0;
        }
        function r(e2, t2) {
          var r2 = q(e2);
          return ~e2.indexOf("%") ? r2 / 100 * t2 : r2;
        }
        function s(e2, t2) {
          return q(e2.getAttribute(t2));
        }
        function u(e2, t2, r2, n2, s2, i) {
          return D(Math.pow((q(r2) - q(e2)) * s2, 2) + Math.pow((q(n2) - q(t2)) * i, 2));
        }
        function v(e2) {
          return console.warn(e2);
        }
        function w(e2) {
          return "non-scaling-stroke" === e2.getAttribute("vector-effect");
        }
        function z(e2) {
          if (!(e2 = k(e2)[0])) return 0;
          var t2, r2, n2, i, o, a, f2, h2 = e2.tagName.toLowerCase(), l2 = e2.style, d2 = 1, c2 = 1;
          w(e2) && (c2 = e2.getScreenCTM(), d2 = D(c2.a * c2.a + c2.b * c2.b), c2 = D(c2.d * c2.d + c2.c * c2.c));
          try {
            r2 = e2.getBBox();
          } catch (e3) {
            v("Some browsers won't measure invisible elements (like display:none or masks inside defs).");
          }
          var g2 = r2 || {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }, _ = g2.x, y = g2.y, x = g2.width, m2 = g2.height;
          if (r2 && (x || m2) || !M[h2] || (x = s(e2, M[h2][0]), m2 = s(e2, M[h2][1]), "rect" !== h2 && "line" !== h2 && (x *= 2, m2 *= 2), "line" === h2 && (_ = s(e2, "x1"), y = s(e2, "y1"), x = Math.abs(x - _), m2 = Math.abs(m2 - y))), "path" === h2) i = l2.strokeDasharray, l2.strokeDasharray = "none", t2 = e2.getTotalLength() || 0, p(d2) !== p(c2) && !b && (b = 1) && v("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), t2 *= (d2 + c2) / 2, l2.strokeDasharray = i;
          else if ("rect" === h2) t2 = 2 * x * d2 + 2 * m2 * c2;
          else if ("line" === h2) t2 = u(_, y, _ + x, y + m2, d2, c2);
          else if ("polyline" === h2 || "polygon" === h2)
            for (n2 = e2.getAttribute("points").match(P) || [], "polygon" === h2 && n2.push(n2[0], n2[1]), t2 = 0, o = 2; o < n2.length; o += 2) t2 += u(n2[o - 2], n2[o - 1], n2[o], n2[o + 1], d2, c2) || 0;
          else "circle" !== h2 && "ellipse" !== h2 || (a = x / 2 * d2, f2 = m2 / 2 * c2, t2 = Math.PI * (3 * (a + f2) - D((3 * a + f2) * (a + 3 * f2))));
          return t2 || 0;
        }
        function A(e2, t2) {
          if (!(e2 = k(e2)[0])) return [0, 0];
          t2 = t2 || z(e2) + 1;
          var r2 = f.getComputedStyle(e2), n2 = r2.strokeDasharray || "", s2 = q(r2.strokeDashoffset), i = n2.indexOf(",");
          return i < 0 && (i = n2.indexOf(" ")), t2 < (n2 = i < 0 ? t2 : q(n2.substr(0, i))) && (n2 = t2), [-s2 || 0, n2 - s2 || 0];
        }
        function B() {
          l() && (f = window, d = t = m(), k = t.utils.toArray, c = t.core.getStyleSaver, g = t.core.reverting || function() {
          }, h = -1 !== ((f.navigator || {}).userAgent || "").indexOf("Edge"));
        }
        var t, k, f, h, d, b, c, g, P = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, M = {
          rect: ["width", "height"],
          circle: ["r", "r"],
          ellipse: ["rx", "ry"],
          line: ["x2", "y2"]
        }, D = Math.sqrt, n = {
          version: "3.11.4",
          name: "drawSVG",
          register: function register(e2) {
            t = e2, B();
          },
          init: function init(e2, t2, n2) {
            if (!e2.getBBox) return false;
            d || B();
            var s2, i, o, a = z(e2);
            return this.styles = c && c(e2, "strokeDashoffset,strokeDasharray,strokeMiterlimit"), this.tween = n2, this._style = e2.style, this._target = e2, t2 + "" == "true" ? t2 = "0 100%" : t2 ? -1 === (t2 + "").indexOf(" ") && (t2 = "0 " + t2) : t2 = "0 0", i = function _parse(e3, t3, n3) {
              var s3, i2, o2 = e3.indexOf(" ");
              return i2 = o2 < 0 ? (s3 = void 0 !== n3 ? n3 + "" : e3, e3) : (s3 = e3.substr(0, o2), e3.substr(o2 + 1)), s3 = r(s3, t3), (i2 = r(i2, t3)) < s3 ? [i2, s3] : [s3, i2];
            }(t2, a, (s2 = A(e2, a))[0]), this._length = p(a), this._dash = p(s2[1] - s2[0]), this._offset = p(-s2[0]), this._dashPT = this.add(this, "_dash", this._dash, p(i[1] - i[0]), 0, 0, 0, 0, 0, 1), this._offsetPT = this.add(this, "_offset", this._offset, p(-i[0]), 0, 0, 0, 0, 0, 1), h && (o = f.getComputedStyle(e2)).strokeLinecap !== o.strokeLinejoin && (i = q(o.strokeMiterlimit), this.add(e2.style, "strokeMiterlimit", i, i + 0.01)), this._live = w(e2) || ~(t2 + "").indexOf("live"), this._nowrap = ~(t2 + "").indexOf("nowrap"), this._props.push("drawSVG"), 1;
          },
          render: function render(e2, t2) {
            if (t2.tween._time || !g()) {
              var r2, n2, s2, i, o = t2._pt, a = t2._style;
              if (o) {
                for (t2._live && (r2 = z(t2._target)) !== t2._length && (n2 = r2 / t2._length, t2._length = r2, t2._offsetPT && (t2._offsetPT.s *= n2, t2._offsetPT.c *= n2), t2._dashPT ? (t2._dashPT.s *= n2, t2._dashPT.c *= n2) : t2._dash *= n2); o; ) o.r(e2, o.d), o = o._next;
                s2 = t2._dash || e2 && 1 !== e2 && 1e-4 || 0, r2 = t2._length - s2 + 0.1, i = t2._offset, s2 && i && s2 + Math.abs(i % t2._length) > t2._length - 0.2 && (i += i < 0 ? 0.1 : -0.1) && (r2 += 0.1), a.strokeDashoffset = s2 ? i : i + 1e-3, a.strokeDasharray = r2 < 0.2 ? "none" : s2 ? s2 + "px," + (t2._nowrap ? 999999 : r2) + "px" : "0px, 999999px";
              }
            } else t2.styles.revert();
          },
          getLength: z,
          getPosition: A
        };
        m() && t.registerPlugin(n), e.DrawSVGPlugin = n, e.default = n;
        if (typeof window === "undefined" || window !== e) {
          Object.defineProperty(e, "__esModule", {
            value: true
          });
        } else {
          delete e.default;
        }
      });
    }
  });
  require_stdin();
})();
/*!
 * DrawSVGPlugin 3.11.4
 * https://greensock.com
 * 
 * @license Copyright 2022, GreenSock. All rights reserved.
 * This plugin is a membership benefit of Club GreenSock and is only authorized for use in sites/apps/products developed by individuals/companies with an active Club GreenSock membership. See https://greensock.com/club
 * @author: Jack Doyle, jack@greensock.com
 */
